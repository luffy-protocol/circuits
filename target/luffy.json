{"noir_version":"0.23.0+5be9f9d7e2f39ca228df10e5a530474af0331704","hash":4017910460484574929,"abi":{"parameters":[{"name":"signer_pub_x_key","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signer_pub_y_key","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"selected_players_points","type":{"kind":"array","length":11,"type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},"visibility":"private"},{"name":"player_points_merkle_paths","type":{"kind":"array","length":11,"type":{"kind":"array","length":6,"type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}},"visibility":"private"},{"name":"all_player_points_merkle_root","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"captain","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"viceCaptain","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"isRandom","type":{"kind":"boolean"},"visibility":"public"},{"name":"selected_player_ids","type":{"kind":"array","length":11,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"selected_squad_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"claimed_player_points","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"}],"param_witnesses":{"all_player_points_merkle_root":[{"start":2592,"end":2624}],"captain":[{"start":2624,"end":2625}],"claimed_player_points":[{"start":2670,"end":2671}],"isRandom":[{"start":2626,"end":2627}],"player_points_merkle_paths":[{"start":480,"end":2592}],"selected_player_ids":[{"start":2627,"end":2638}],"selected_players_points":[{"start":128,"end":480}],"selected_squad_hash":[{"start":2638,"end":2670}],"signature":[{"start":64,"end":128}],"signer_pub_x_key":[{"start":0,"end":32}],"signer_pub_y_key":[{"start":32,"end":64}],"viceCaptain":[{"start":2625,"end":2626}]},"return_type":null,"return_witnesses":[]},"bytecode":"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","debug_symbols":"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","file_map":{"25":{"source":"mod hash;\nmod array;\nmod slice;\nmod merkle;\nmod schnorr;\nmod ecdsa_secp256k1;\nmod ecdsa_secp256r1;\nmod eddsa;\nmod grumpkin_scalar;\nmod grumpkin_scalar_mul;\nmod scalar_mul;\nmod sha256;\nmod sha512;\nmod field;\nmod ec;\nmod unsafe;\nmod collections;\nmod compat;\nmod option;\nmod string;\nmod test;\nmod cmp;\nmod ops;\nmod default;\nmod prelude;\nmod uint128;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(_with_newline: bool, _input: T) {}\n\nunconstrained pub fn print<T>(input: T) {\n    print_oracle(false, input);\n}\n\nunconstrained pub fn println<T>(input: T) {\n    print_oracle(true, input);\n}\n\n#[foreign(recursive_aggregation)]\npub fn verify_proof<N>(_verification_key: [Field], _proof: [Field], _public_inputs: [Field], _key_hash: Field) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(_x: T) {}\n// from_field and as_field are private since they are not valid for every type.\n// `as` should be the default for users to cast between primitive types, and in the future\n// traits can be used to work with generic types.\n#[builtin(from_field)]\nfn from_field<T>(_x: Field) -> T {}\n\n#[builtin(as_field)]\nfn as_field<T>(_x: T) -> Field {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) + crate::as_field(y))\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T {\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    crate::from_field(crate::as_field(x) + 340282366920938463463374607431768211456 - crate::as_field(y))\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * crate::as_field(y))\n}\n","path":"std/lib.nr"},"43":{"source":"mod tests;\nuse dep::std;\nuse dep::ecrecover;\n\nglobal MERKLE_DEPTH = 6;\nfn main(\n    signer_pub_x_key: [u8; 32],\n    signer_pub_y_key: [u8; 32],\n    signature: [u8; 64],\n    selected_players_points: [[u8; 32]; 11],\n    player_points_merkle_paths: [[[u8; 32]; MERKLE_DEPTH]; 11],\n    all_player_points_merkle_root: [u8; 32],\n    captain: pub u8,\n    viceCaptain: pub u8,\n    isRandom: pub bool,\n    selected_player_ids: pub [u8; 11],\n    selected_squad_hash: pub [u8; 32],\n    claimed_player_points: pub u64\n) {\n    ecdsa_verification(\n        signer_pub_x_key,\n        signer_pub_y_key,\n        signature,\n        selected_squad_hash\n    );\n\n    verify_squad_hash(selected_player_ids, selected_squad_hash);\n\n    // verify_all_merkle_roots(\n    //     selected_player_ids,\n    //     selected_players_points,\n    //     player_points_merkle_paths,\n    //     all_player_points_merkle_root\n    // );\n\n    let mut calculated_total_points: u64 = 0;\n    let mut counter: u8 = 0;\n    let mut captainMultiplier: u64 = 0;\n    let mut viceCaptainMultiplier: u64 = 0;\n\n    if isRandom {\n        captainMultiplier = 4;\n        viceCaptainMultiplier = 3;\n    } else {\n        captainMultiplier = 3;\n        viceCaptainMultiplier = 2;\n    }\n\n    for point in selected_players_points {\n        let mut player_point: u64 = 0;\n        for byte in point {\n            player_point += byte as u64;\n        }\n        if counter == captain {\n            player_point = player_point * captainMultiplier;\n        } else if counter == viceCaptain {\n            player_point = player_point * viceCaptainMultiplier;\n        }\n        calculated_total_points += player_point;\n        counter += 1;\n    }\n\n    assert(calculated_total_points == claimed_player_points);\n}\n\nfn verify_squad_hash(player_ids: [u8; 11], squad_hash: [u8; 32]) {\n    let computed_squad_hash= std::hash::keccak256(player_ids, 11);\n    assert(computed_squad_hash == squad_hash);\n}\n\nfn ecdsa_verification(\n    signer_pub_x_key: [u8; 32],\n    signer_pub_y_key: [u8; 32],\n    signature: [u8; 64],\n    hash: [u8; 32]\n) {\n    let computedAddress: Field = ecrecover::secp256k1::PubKey::from_xy(signer_pub_x_key, signer_pub_y_key).to_eth_address(); // Compute address from public key\n    let recoveredAddress = ecrecover::ecrecover(signer_pub_x_key, signer_pub_y_key, signature, hash);\n\n    println(f\"Computed address: {computedAddress}\");\n    println(f\"Recovered address: {recoveredAddress}\");\n    assert(computedAddress == recoveredAddress);\n}\n\nfn verify_all_merkle_roots(\n    player_ids: [u8; 11],\n    players_points: [[u8; 32]; 11],\n    merkle_paths: [[[u8; 32]; MERKLE_DEPTH]; 11],\n    merkle_root: [u8; 32]\n) {\n    for i in 0..11 {\n        compute_and_verify_merkle_root(players_points[i], player_ids[i], merkle_paths[i], merkle_root);\n    }\n}\n\nfn compute_and_verify_merkle_root(\n    leaf: [u8; 32],\n    leaf_index: u8,\n    proof: [[u8; 32]; MERKLE_DEPTH],\n    all_points_merkle_root: [u8; 32]\n) {\n    let mut computed_merkle_root: [u8; 32] = [0; 32];\n    computed_merkle_root=leaf;\n    let mut leaf_index_mut= leaf_index;\n    for i in 0..MERKLE_DEPTH {\n        if leaf_index_mut % 2 == 0 {\n            computed_merkle_root = std::hash::keccak256(concatenate_leafs(computed_merkle_root, proof[i]), 64);\n        } else {\n            computed_merkle_root = std::hash::keccak256(concatenate_leafs(proof[i], computed_merkle_root), 64);\n        }\n        leaf_index_mut = leaf_index_mut / 2;\n    }\n\n    println(f\"Computed merkle root: {computed_merkle_root}\");\n    println(f\"All points merkle root: {all_points_merkle_root}\");\n    assert(computed_merkle_root == all_points_merkle_root);\n}\n\nfn concatenate_leafs(leaf1: [u8; 32], leaf2: [u8; 32]) -> [u8; 64] {\n    let mut arr: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        arr[i] = leaf1[i];\n        arr[i + 32] = leaf2[i];\n    }\n    arr\n}\n","path":"/Users/gabrielantonyxaviour/Developer/projects/luffy/circuits/src/main.nr"},"44":{"source":"use dep::std;\n \nmod secp256k1;\n\nfn ecrecover(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64], // clip v value\n    hashed_message: [u8; 32]\n) -> Field {\n    let key = secp256k1::PubKey::from_xy(pub_key_x, pub_key_y);\n\n    assert(key.verify_sig(signature, hashed_message));\n    let addr = key.to_eth_address();\n\n    addr\n}\n\n#[test]\nfn test_ecrecover() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let addr = ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/ecrecover-noirv0.19.0/src/lib.nr"},"45":{"source":"use dep::std;\n\nuse dep::array_helpers;\n\nstruct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nunconstrained\nfn split_uncompressed_pub_key(\n    pub_key: [u8; 65]\n) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    };\n\n    (pub_key_x, pub_key_y)\n}\n\nimpl PubKey {\n    fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PubKey {\n        PubKey {\n            pub_x,\n            pub_y,\n        }\n    }\n\n    fn from_unified(pub_key: [u8; 64]) -> PubKey {\n        let (key_x, key_y) = array_helpers::split_u8_64_unconstrained(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn from_uncompressed(pub_key: [u8; 65]) -> PubKey {\n        assert(pub_key[0] == 0x04);\n        let (key_x, key_y) = split_uncompressed_pub_key(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn verify_sig(self, signature: [u8; 64], hashed_message: [u8; 32]) -> bool {\n        std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message)\n    }\n\n    fn to_eth_address(self) -> Field {\n        let pub_key = array_helpers::u8_32_to_u8_64_unconstrained(self.pub_x, self.pub_y);\n        let hashed_pub_key = std::hash::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            // shift left by 8 and add the new value\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(\n        self,\n        signature: [u8; 64],\n        hashed_message: [u8; 32]\n    ) -> Field {\n        assert(self.verify_sig(signature, hashed_message));\n\n        self.to_eth_address()\n    }\n}\n\n\n#[test]\nfn test_ecrecover_via_key() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let key = PubKey::from_xy(pub_key_x, pub_key_y);\n    assert(key.ecrecover(signature, hashed_message) == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/ecrecover-noirv0.19.0/src/secp256k1.nr"},"46":{"source":"use dep::std;\n\nfn u8_32s_to_u64_16(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\nunconstrained\nfn u8_32s_to_u64_16_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\n#[test]\nfn test_u8_32s_to_u64_16() {\n    let arr_a: [u8; 32] = [\n        131,24,83,91,84,16,93,74,122,174,96,192,143,196,95,150,135,24,27,79,223,198,37,189,26,117,63,167,57,127,237,117\n    ];\n    let arr_b: [u8; 32] = [\n        53,71,241,28,168,105,102,70,242,243,172,176,142,49,1,106,250,194,62,99,12,93,17,245,159,97,254,245,123,13,42,165\n    ];\n    let out = u8_32s_to_u64_16(arr_a, arr_b);\n\n    assert(out[0] == 9446391870127103306);\n    assert(out[1] == 8840109498736861078);\n    assert(out[2] == 9734560624431998397);\n    assert(out[3] == 1906500004718046581);\n    assert(out[4] == 3839302312743495238);\n    assert(out[5] == 17506526050819047786);\n    assert(out[6] == 18069073250093961717);\n    assert(out[7] == 11484740855056378533);\n    assert(out[8] == 0);\n    assert(out[9] == 0);\n    assert(out[10] == 0);\n    assert(out[11] == 0);\n    assert(out[12] == 0);\n    assert(out[13] == 0);\n    assert(out[14] == 0);\n    assert(out[15] == 0);\n    // the above output is the hex \"0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5\"\n}\n\nfn u8_32_to_u8_64(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\nunconstrained\nfn u8_32_to_u8_64_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\n\nfn u64_4_to_u8_32(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\nunconstrained\nfn u64_4_to_u8_32_unconstrained(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\n#[test]\nfn test_u64_4_to_u8_32() {\n    let hash: [u64; 4] = [\n        999647796417551690,\n        8840109498736861078,\n        9734560624431998397,\n        1906500004718046581\n    ];\n \n    let arr_out = u64_4_to_u8_32(hash);\n\n    assert(arr_out[0] == 13);\n    assert(arr_out[1] == 223);\n    assert(arr_out[2] == 118);\n    assert(arr_out[3] == 95);\n    assert(arr_out[4] == 221);\n    assert(arr_out[5] == 248);\n    assert(arr_out[6] == 93);\n    assert(arr_out[7] == 74);\n    assert(arr_out[8] == 122);\n    assert(arr_out[9] == 174);\n    assert(arr_out[10] == 96);\n    assert(arr_out[11] == 192);\n    assert(arr_out[12] == 143);\n    assert(arr_out[13] == 196);\n    assert(arr_out[14] == 95);\n    assert(arr_out[15] == 150);\n    assert(arr_out[16] == 135);\n    assert(arr_out[17] == 24);\n    assert(arr_out[18] == 27);\n    assert(arr_out[19] == 79);\n    assert(arr_out[20] == 223);\n    assert(arr_out[21] == 198);\n    assert(arr_out[22] == 37);\n    assert(arr_out[23] == 189);\n    assert(arr_out[24] == 26);\n    assert(arr_out[25] == 117);\n    assert(arr_out[26] == 63);\n    assert(arr_out[27] == 167);\n    assert(arr_out[28] == 57);\n    assert(arr_out[29] == 127);\n    assert(arr_out[30] == 237);\n    assert(arr_out[31] == 117);\n}\n\n/// @dev this method is used to convert a u8 array to a u160 (which is not supported by Noir, so it's represented as a Field)\n/// @dev will throw on Field overflow\nfn u8_to_u160(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nunconstrained\nfn u8_to_u160_unconstrained(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nfn u8_to_eth_address(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\nunconstrained\nfn u8_to_eth_address_unconstrained(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\n#[test]\nfn test_u8_32_to_u160() {\n    // keccak hash of hardhat 0 address pub key (0xc1ffd3cfee2d9e5cd67643f8f39fd6e51aad88f6f4ce6ab8827279cfffb92266) as u8 array\n    let hashed_pub_key = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let mut right_20_bytes: [u8] = [0; 20];\n    for i in 0..20 {\n        right_20_bytes[i] = hashed_pub_key[i + 12];\n    }\n\n    let addr = u8_to_u160(right_20_bytes);\n    let addr_aliased = u8_to_eth_address(right_20_bytes);\n\n    assert(addr == addr_aliased);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266); // hardhat address 0\n}\n\nfn split_u8_64(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\nunconstrained\nfn split_u8_64_unconstrained(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\n#[test]\nfn test_split_u8_64() {\n    let u8_64 = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102,\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let (arr_a, arr_b) = split_u8_64(u8_64);\n\n    for i in 0..32 {\n        assert(arr_a[i] == u8_64[i]);\n        assert(arr_b[i] == u8_64[i + 32]);\n    }\n}\n","path":"/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/noir-array-helpersv0.19.0/src/lib.nr"}}}